#!/usr/bin/env python3
"""
FAROSINT - Módulo de Detección de Vulnerabilidades
VERSIÓN SIMPLIFICADA - Una sola ejecución de Nuclei
"""

import subprocess
import json
import logging
import shutil
from pathlib import Path
from typing import List, Dict
import yaml
import re

logger = logging.getLogger(__name__)

class VulnerabilityScanModule:
    """Módulo de detección de vulnerabilidades con Nuclei"""

    def __init__(self, config_path: str = None):
        if config_path and Path(config_path).exists():
            with open(config_path, 'r') as f:
                self.config = yaml.safe_load(f)
        else:
            self.config = {'timeouts': {'nuclei': 1800}}

        self.timeout = self.config.get('timeouts', {})
        self.logger = logging.getLogger(__name__)

        # Encontrar ruta de nuclei
        self.nuclei_path = self._find_nuclei_path()

    def _find_nuclei_path(self):
        """Encuentra la ruta absoluta de nuclei"""
        # Buscar en rutas conocidas primero (evitar shutil.which que puede
        # encontrar el binario equivocado si hay varios en PATH)
        search_paths = [
            Path.home() / 'go' / 'bin' / 'nuclei',
            Path('/usr/local/bin/nuclei'),
            Path('/usr/bin/nuclei'),
            Path.home() / '.local' / 'bin' / 'nuclei'
        ]

        for path in search_paths:
            if path.exists() and path.is_file():
                return str(path)

        # Fallback a shutil.which
        nuclei_path = shutil.which('nuclei')
        if nuclei_path:
            return nuclei_path

        return 'nuclei'
        
    def run_nuclei(self, input_file: str, output_file: str, bypass_waf: bool = True) -> Dict:
        """
        Ejecuta Nuclei - UNA SOLA VEZ con todos los templates
        """
        self.logger.info(f"[NUCLEI] Escaneando URLs desde: {input_file}")
        
        if not Path(input_file).exists():
            return {'success': False, 'error': 'Input file not found', 'vulnerabilities': []}
        
        # Comando simplificado - Nuclei usa TODOS sus templates por defecto
        cmd = [
            self.nuclei_path,
            '-l', input_file,
            '-jsonl',  # Output en JSON Lines
            '-o', output_file,
            '-silent',  # Sin output extra
            '-stats'    # Mostrar estadísticas al final
        ]
        
        # Headers anti-WAF
        if bypass_waf:
            cmd.extend([
                '-H', 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            ])
        
        # Ejecutar comando
        self.logger.info(f"[NUCLEI] Comando: {' '.join(cmd)}")
        
        try:
            result = subprocess.run(
                cmd,
                timeout=self.timeout.get('nuclei', 1800),
                capture_output=True,
                text=True
            )

            # Loguear return code y stderr a nivel WARNING (visible en consola)
            if result.returncode != 0:
                print(f"[Nuclei] WARNING: exit code {result.returncode}")
                if result.stderr:
                    # Mostrar últimas líneas de stderr (errores relevantes)
                    stderr_lines = result.stderr.strip().split('\n')
                    for line in stderr_lines[-10:]:
                        if line.strip():
                            print(f"[Nuclei] stderr: {line.strip()}")

            # Parsear resultados del archivo JSONL
            vulnerabilities = []

            if Path(output_file).exists():
                file_size = Path(output_file).stat().st_size
                if file_size == 0:
                    print(f"[Nuclei] Output vacío (0 bytes) - Nuclei no encontró resultados")
                else:
                    with open(output_file, 'r') as f:
                        for line_num, line in enumerate(f, 1):
                            line = line.strip()
                            if not line:
                                continue
                            try:
                                vuln = json.loads(line)
                                vulnerabilities.append(vuln)
                            except json.JSONDecodeError as e:
                                self.logger.warning(f"[NUCLEI] Error parsing línea {line_num}: {e}")
                                continue
            else:
                print(f"[Nuclei] WARNING: Output file no fue creado: {output_file}")

            print(f"[Nuclei] Vulnerabilidades encontradas: {len(vulnerabilities)}")

            enriched = self._enrich_vulnerabilities(vulnerabilities)

            return {
                'success': result.returncode == 0,
                'error': f'exit code {result.returncode}' if result.returncode != 0 else '',
                'vulnerabilities': enriched,
                'count': len(enriched),
                'output_file': output_file
            }
            
        except subprocess.TimeoutExpired:
            self.logger.warning(f"[NUCLEI] Timeout después de {self.timeout.get('nuclei')}s")
            
            # Leer resultados parciales
            vulnerabilities = []
            if Path(output_file).exists():
                with open(output_file, 'r') as f:
                    for line in f:
                        try:
                            vulnerabilities.append(json.loads(line.strip()))
                        except:
                            pass
            
            enriched = self._enrich_vulnerabilities(vulnerabilities)
            
            return {
                'success': False,
                'error': 'timeout',
                'vulnerabilities': enriched,
                'count': len(enriched)
            }
            
        except Exception as e:
            self.logger.error(f"[NUCLEI] Error: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            return {'success': False, 'error': str(e), 'vulnerabilities': [], 'count': 0}
    
    def _enrich_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Enriquece vulnerabilidades con MITRE/OWASP/CVE"""
        enriched = []
        
        for vuln in vulnerabilities:
            info = vuln.get('info', {})
            name = info.get('name', 'Unknown')
            severity = info.get('severity', 'unknown')
            
            # Extraer CVE
            cve_match = re.search(r'CVE-\d{4}-\d{4,7}', name)
            cve = cve_match.group(0) if cve_match else None
            
            enriched_vuln = {
                'name': name,
                'severity': severity,
                'matched_at': vuln.get('matched-at', ''),
                'host': vuln.get('host', ''),
                'type': vuln.get('type', ''),
                'template': info.get('template', ''),
                'tags': info.get('tags', []),
                'references': {}
            }
            
            # CVE Details
            if cve:
                enriched_vuln['cve'] = cve
                enriched_vuln['references']['cve_details'] = f"https://cvedetails.com/cve/{cve}/"
                enriched_vuln['references']['nvd'] = f"https://nvd.nist.gov/vuln/detail/{cve}"
            
            # MITRE ATT&CK
            mitre_techniques = {
                'http': 'T1190',
                'file': 'T1083',
                'network': 'T1046'
            }
            
            vuln_type = enriched_vuln.get('type', 'http')
            if vuln_type in mitre_techniques:
                tech = mitre_techniques[vuln_type]
                enriched_vuln['references']['mitre'] = f"https://attack.mitre.org/techniques/{tech}/"
            
            # OWASP
            owasp_categories = {
                'critical': 'A01_2021-Broken_Access_Control',
                'high': 'A03_2021-Injection',
                'medium': 'A05_2021-Security_Misconfiguration',
                'low': 'A09_2021-Security_Logging_and_Monitoring_Failures'
            }
            
            if severity in owasp_categories:
                cat = owasp_categories[severity]
                enriched_vuln['references']['owasp'] = f"https://owasp.org/Top10/{cat}/"
            
            # CVSS Score
            cvss_scores = {
                'critical': 9.0,
                'high': 7.5,
                'medium': 5.0,
                'low': 3.0,
                'info': 0.0
            }
            enriched_vuln['cvss_score'] = cvss_scores.get(severity, 0.0)
            
            # Remediation
            enriched_vuln['remediation'] = self._generate_remediation(enriched_vuln)
            
            enriched.append(enriched_vuln)
        
        return enriched
    
    def _generate_remediation(self, vuln: Dict) -> Dict:
        """Genera recomendaciones de remediación"""
        severity = vuln.get('severity', 'unknown')
        
        priorities = {
            'critical': 'P0 - Inmediato (0-24h)',
            'high': 'P1 - Urgente (1-7 días)',
            'medium': 'P2 - Normal (1-30 días)',
            'low': 'P3 - Bajo (próxima ventana)',
            'info': 'P4 - Informativo'
        }
        
        steps = {
            'critical': [
                'Aplicar parche de seguridad inmediatamente',
                'Verificar si el sistema fue comprometido',
                'Revisar logs de acceso',
                'Notificar al equipo de seguridad'
            ],
            'high': [
                'Aplicar parche en ventana de emergencia',
                'Implementar controles compensatorios',
                'Monitorear actividad relacionada'
            ],
            'medium': [
                'Programar actualización en mantenimiento',
                'Aplicar controles compensatorios',
                'Monitorear'
            ],
            'low': [
                'Revisar en próxima ventana',
                'Documentar para análisis'
            ]
        }
        
        return {
            'priority': priorities.get(severity, 'P3'),
            'steps': steps.get(severity, ['Revisar documentación'])
        }


def scan_vulnerabilities(urls_file: str, output_dir: str, config_path: str = None) -> Dict:
    """Función principal de escaneo"""
    module = VulnerabilityScanModule(config_path)
    
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    output_file = output_path / 'vulnerabilities.jsonl'
    
    result = module.run_nuclei(urls_file, str(output_file), bypass_waf=True)
    
    # Guardar en formato legible
    if result.get('vulnerabilities'):
        readable_file = output_path / 'vulnerabilities_readable.txt'
        with open(readable_file, 'w') as f:
            for vuln in result['vulnerabilities']:
                f.write(f"\n{'='*80}\n")
                f.write(f"VULNERABILIDAD: {vuln['name']}\n")
                f.write(f"Severidad: {vuln['severity'].upper()}\n")
                f.write(f"CVSS: {vuln.get('cvss_score', 'N/A')}\n")
                f.write(f"Host: {vuln.get('host', 'N/A')}\n")
                f.write(f"Template: {vuln.get('template', 'N/A')}\n")
                
                if vuln.get('cve'):
                    f.write(f"CVE: {vuln['cve']}\n")
                
                f.write(f"\nREFERENCIAS:\n")
                for ref_name, ref_url in vuln.get('references', {}).items():
                    f.write(f"  - {ref_name}: {ref_url}\n")
                
                f.write(f"\nREMEDIACIÓN:\n")
                rem = vuln.get('remediation', {})
                f.write(f"  Prioridad: {rem.get('priority', 'N/A')}\n")
                for step in rem.get('steps', []):
                    f.write(f"  • {step}\n")
        
        result['readable_file'] = str(readable_file)
    
    return result
